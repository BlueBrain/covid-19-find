import optlib as opt
import pandas as pd
import cdata as cd
import ast
import os
import json
import numpy as np
from multiprocessing import Pool, cpu_count,Process,Queue,Manager
from datetime import datetime
import sys

cl_path_prefix = os.path.abspath(os.path.dirname(__file__))

#---------------------------------------------------------------
# This program ingests the death and test data for individual countries and uses this data to divide the epidemic into phases 
# characterised by a homogeneous level of government intervention. For optimal performance of the simulator, the program should be run periodically (ideally daily)
# The program computes two time series representing respectively the start date of each phase (measured in days since November 23, 2019, 
# and the severity of government intervention represented by a custom metric with minimum value 0 and maximum value 1). 
# The time series are computed to minimize the difference between the actual death values and the values generated by the simulation 
# given the values of the time series, as represented in a "score".
# To accelerate the computation, the program only considers phases for a certain number of days in the past defined in "days_considered"
# As a further acceleration the program does not compute new parameters for countries where the "score" of a new simulation with the existing parameters is less than or equal to "tolerance".
# Computations for different countries are executed in parallel using n_processors-2
#---------------------------------------------------------------- 

def process_countries(queue_in, queue_out,tolerance,days_considered):

    today=datetime.now()
    day1= datetime.strptime('2019-11-23',"%Y-%m-%d")
    db1_path=cl_path_prefix
    db1_long_name =os.path.join(db1_path, 'db1_long.csv')
    df_old_values = pd.read_csv(db1_long_name,keep_default_na=False)
    sim_days=(today-day1).days
    start_extend=sim_days-days_considered # uaed to be 60
    while not queue_in.empty():
      ccode=queue_in.get()
      if cd.checkcountryparams(ccode) is not None:
         cname = cd.getcountryname(ccode)
         print("COUNTRY:",cname, '('+ccode+')')
         opt.setcountry(ccode)
         print ('Currently processing', ccode)
         old_sev,old_trig,old_long_sev, old_long_trig, old_score,method=opt.get_previous_parameters(df_old_values, cname)
         dfx,simulated_score=opt.simulate_with_old_parameters(old_sev,old_trig,cname)
         if simulated_score<tolerance:
             sev=old_sev
             trig=old_trig
             longsev=old_long_sev 
             longtrig=old_long_trig
             score=simulated_score
             method='Old result good enough'
         else:
             print('Currently optimizing', ccode)
             opt.setlengths(7,28,50)
             if len(old_long_sev) > 1:
              while (old_long_trig[-1] > start_extend):
                old_long_sev.pop()
                old_long_trig.pop()
             score,dfx,sev,trig,longsev,longtrig = opt.extendphases(ccode,old_long_sev,old_long_trig)
             method='reoptimized on extend'
             if score>simulated_score:
                 sev=old_sev
                 trig=old_trig
                 longsev=old_long_sev 
                 longtrig=old_long_trig
                 score=simulated_score
                 method='Old result retained on extend - better than new '
         opt.showthiscase(dfx,sev,trig,'EXT')
          #problem in line below - 'cannot set a row with misplaced columns
         short_result = [ccode, cname, sev, trig, score, method]
         long_result = [ccode, cname, sev, trig, score, longsev, longtrig,method]
         queue_out.put([short_result,long_result])
         
         
         

if __name__=='__main__':
    db1_path=cl_path_prefix
    db1_short_name =os.path.join(db1_path, 'db1.csv')
    db1_long_name =os.path.join(db1_path, 'db1_long.csv')
    short_results=[]
    long_results=[]
    manager=Manager()
    queue_in=Queue()
    queue_out=manager.Queue()
    tolerance=0.015
    days_considered=350
    n_processors=cpu_count()-2
    if n_processors<1:
        n_processors=1
    print('starting',datetime.now())
    df = pd.DataFrame(columns=['Code', 'Country', 'Severities', 'Trigger Dates', 'Score','Method'])
    df_long = pd.DataFrame(columns=['Code', 'Country', 'Severities', 'Trigger Dates', 'Score', 'Long Sev', 'Long Trig','Method'])
    
    df_old_values = pd.read_csv(db1_long_name,keep_default_na=False)
#    queue_in.put(df_old_values['Code'][i]for i in range(0,len(df_old_values)))
    for i in range(0,len(df_old_values)):
        queue_in.put(df_old_values['Code'][i])
    processes = [Process(target=process_countries, args=(queue_in,queue_out,tolerance,days_considered)) for i in range(0,n_processors)]
    for p in processes:
        p.start()
    for p in processes:
        p.join()
    while not queue_out.empty():
        a_result=queue_out.get()
        short_result=a_result[0]
        long_result=a_result[1]
        short_results.append(short_result)
        long_results.append(long_result)
    df=pd.DataFrame(short_results,columns=['Code', 'Country', 'Severities', 'Trigger Dates', 'Score','Method'])
    df.to_csv(db1_short_name)
    df_long=pd.DataFrame(long_results,columns=['Code', 'Country', 'Severities', 'Trigger Dates', 'Score', 'Long Sev', 'Long Trig','Method'])
    df_long.to_csv(db1_long_name)      
    print('finished',datetime.now())
    

   
 